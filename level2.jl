# выболнить большую часть заданий ниже:

"""
======================================================================
1. Система типов: приведение к типам,
конкретные и абстрактные типы,
множественная диспетчеризация
"""

"""
что происходит с типами, какого типа `c` и почему?
"""
a = 1
b = 2.0
c = a + b
typeof(a)
typeof(b)
typeof(c)
"""
написать тип, параметризованный другим типом
"""
struct ParamTypes{T<:Real}
    a::T
    b::T
end
ParamTypes(10,5)
"""
написать функцию для двух аругментов, не указывая их тип,
и вторую функцию от двух аргментов с конкретными типами,
дать пример запуска
"""
sum_func(a,b) = a + b
sum2_func(a::Float64,b::Int) = a + b
sum_func(1,4) #вывод Int 5
sum2_func(1.0,4) #вывод Float64 5.0
"""
абстрактный тип - ключевое слово?
примитивный тип - ключевое слово?
композитный тип - ключевое слово?
"""
abstract type NewAbstractTypes <:Real end #абстрактный тип
NewAbstractTypes <: Real

primitive type Int8 <: Signed 8 end #примитивный тип

struct Numbers #композитный тип
    a::Float64
    b::Int
end
new_number = Numbers(5.2, 100)
typeof(new_number)
new_number.a
"""
написать один абстрактный тип и два его подтипа (1 и 2)
написать функцию над абстрактным типом, и функцию над её подтипом-1
выполнить функции над объектами подтипов 1 и 2 и объяснить результат
(функция выводит произвольный текст в консоль)
"""
#abstract type Main_type end
#abstract type first_type <: AbsParentType end
#abstract type second_type <: AbsParentType end
#abs_first_function(a::Main_type) = print(a)
#abs_second_function(a::first_type) = print(a)
#abs_first_function()
"""
======================================================================
2. Функции:
лямбды и обычные функции,
переменное количество аргументов,
именованные аргументы со значениями по умолчанию,
кортежи
"""

"""
пример обычной функции
"""
function new_function(a)
    print("press $a")
end
new_function("A")
"""
пример лямбда-функции (аннонимной функции)
"""
lambda_function = x -> 2*x
lambda_function(25) #вывод 50
"""
пример функции с переменным количеством аргументов
"""
varargFunction(a,b,x...) = (a,b,x)
varargFunction(10, 20, 30)
"""
пример функции с именованными аргументами
"""
function key_function(a; b=200)
    a = a-a*b/100
end
"""
функции с переменным кол-вом именованных аргументов
"""
function key2_function(a; b...)
    a = a-a*b/100
end 
"""
передать кортеж в функцию, которая принимает на вход несколько аргументов
присвоить кортеж результату функции, которая возвращает несколько аргументов
использовать splatting - деструктуризацию кортежа в набор аргументов
"""
function tuple_function(a,b,(c,d,e))
    return (c+a,d*b,e*(a+b))
end
tuple_function(10,12,(23,34,56))
"""
======================================================================
3. loop fusion, broadcast, filter, map, reduce
"""

"""
перемножить все элементы массива
с помощью reduce
"""
reduce(op, itr; [init])
reduce(*,[1;2;3])
"""
написать функцию от одного аргумента и запустить ее по всем элементам массива
с помощью точки (broadcast)
c помощью map
указать, чем это лучше явного цикла?
"""
my_function(a) = a*a
vector = [2,2,3,3]
my_function.(vector)
map(my_function,vector)
"""
перемножить вектор-строку [1 2 3] на вектор-столбец [10,20,30] и объяснить результат
"""
vector_string = [2 2 1]
vector_column = [10,20,30]
result = vector_string*vector_column
"""
в одну строку выбрать из массива [1, -2, 2, 3, 4, -5, 0] только четные и положительные числа
"""
#vec = [1, -2, 2, 3, 4, -5, 0]
filter(x -> iseven(x) && x>0,[1, -2, 2, 3, 4, -5, 0]) 

"""
======================================================================
4. Свой тип данных на общих интерфейсах
"""

"""
написать свой тип ленивого массива, каждый элемент которого
вычисляется при взятии индекса (getindex) по формуле (index - 1)^2
"""
mutable struct myArray
    index::Int
end
"""
Написать два типа объектов команд, унаследованных от AbstractCommand,
которые применяются к массиву:
`SortCmd()` - сортирует исходный массив
`ChangeAtCmd(i, val)` - меняет элемент на позиции i на значение val
Каждая команда имеет конструктор и реализацию метода apply!
"""
abstract type AbstractCommand end
apply!(cmd::AbstractCommand, target::Vector) = error("Not implemented for type $(typeof(cmd))")


"""
Аналогичные команды, но без наследования и в виде замыканий (лямбда-функций)
"""

"""
======================================================================
5. Тесты: как проверять функции?
"""

"""
написать тест для функции
"""

"""
======================================================================
6. Дебаг: как отладить функцию по шагам?
"""

"""
написать и отладить функцию по шагам с помощью макроса @enter и точек останова
"""

"""
======================================================================
7. Профилировщик: как оценить производительность функции?

"""

"""
оценить производительность функции с помощью макроса @profview
"""
function generate_data(len)
    vec1 = Any[]
    for k = 1:len
        r = randn(1,1)
        append!(vec1, r)
    end
    vec2 = sort(vec1)
    vec3 = vec2 .^ 3 .- (sum(vec2) / len)
    return vec3
end

@time generate_data(1_000_000);

"""
предложить, как переписать функцию так, чтобы она выполнялась быстрее?
"""

"""
======================================================================
8. Отличия от матлаба: приращение массива и предварительная аллокация?
"""

"""
написать функцию определения первой разности, которая принимает и возвращает массив
и для каждой точки входного (x) и выходного (y) выходного массива вычисляет:
y[i] = x[i] - x[i-1]
"""

"""
аналогичная функция, которая отличается тем, что внутри себя не аллоцирует новый массив y,
а принимает его первым аргументом, сам массив аллоцируется до вызова функции
"""

"""
написать код, который добавляет элементы в конец массива, в начало массива,
в середину массива
"""

"""
======================================================================
9. Модули и функции: как оборачивать функции внутрь модуля, как их экспортировать
и пользоваться вне модуля?
"""


"""
написать модуль с двумя функциями,
экспортировать одну из них,
воспользоваться обеими функциями вне модуля
"""
module Foo
    #export ?
end
# using .Foo ?
# import .Foo ?

"""
======================================================================
10. Зависимости, окружение и пакеты
"""

"""
что такое environment, как задать его, как его поменять во время работы?
"""

"""
что такое пакет (package), как добавить новый пакет?
"""

"""
как начать разрабатывать чужой пакет?
"""

"""
как создать свой пакет? (сложный вопрос, поэтому необязательно)
"""

"""
======================================================================
11. Аргументы запуска Julia
"""

"""
Как задать окружение при запуске?
"""

"""
Как задать скрипт, который будет выполняться при запуске:
а) из файла .jl
б) из текста команды? (см. флаг -e)
"""
